<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meteorite Landings</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/versor@0.2/dist/versor.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
        body { margin: 0; }
        .tooltip { 
            position: absolute; 
            background: rgba(0, 0, 0, 0.7); 
            color: #fff; 
            padding: 5px; 
            border-radius: 3px; 
            pointer-events: none; 
            display: none; 
        }
        .chart-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .chart-row {
            width: 100%;
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        .chart {
            margin: 0 10px;
        }
        .text-container {
            width: 20%;
            padding: 10px;
            box-sizing: border-box;
        }
        .text-left {
            text-align: left;
        }
        .text-right {
            text-align: right;
        }
        .bar-chart-container,
        .stacked-bar-chart-container {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
        }
        .bar-chart {
            height: 300px;
            width: 50%;
        }
        .stacked-bar-chart {
            height: 300px;
            width: 50%;
        }
        .map-container {
            width: 100%;
            height: calc(100vh - 600px); /* Adjust height for the map */
            position: relative;
        }
        #mapCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="tooltip"></div>
    <div class="chart-container">
        <!-- Row for the Bar Chart and its left-side text -->
        <div class="chart-row">
            <div class="text-container text-left">
                <h2>The Heaviest Meteorites Ever Recorded</h2>
                <p>According to National Geographic, the largest meteorite ever discovered on Earth is the Hoba meteorite, found in Namibia in 1920. 
                    Weighing approximately 54,000 kilograms (119,000 pounds), the Hoba meteorite is so massive that it remains in its original location. 
                    Its enormous size and weight make it impossible to move, and it has been preserved exactly where it was discovered. 
                    This remarkable meteorite offers a unique opportunity to study an extraterrestrial object in its natural setting.
                </p>
            </div>
            <div class="chart bar-chart-container">
                <div class="bar-chart"></div>
            </div>
        </div>

        <!-- Row for the Stacked Bar Chart and its right-side text -->
        <div class="chart-row">
            <div class="chart stacked-bar-chart-container">
                <div class="stacked-bar-chart"></div>
            </div>
            <div class="text-container text-right">
                <h2>Number of Finds Over Time</h2>
                <p>
                    There are several factors contributing to the increase in meteorite finds over recent years. 
                    Primarily, climate change and advancements in transportation technology have played significant roles. 
                    The melting of Arctic ice has uncovered numerous meteorite specimens that were previously inaccessible. 
                    Additionally, our rapid technological progress has enabled us to retrieve meteorites from the Moon's craters. 
                    This combination of environmental and technological changes has greatly enhanced our ability to discover and study meteorites. 
                </p>
            </div>
        </div>
    </div>

    <div class="map-container">
        <canvas id="mapCanvas"></canvas>
    </div>
    
    <script>
        const chartContainerHeight = 600; // Combined height for the charts section
        const width = window.innerWidth;
        const height = window.innerHeight - chartContainerHeight; // Height for the map
        const radius = Math.min(width, height) / 2.2; // Adjust scale for the globe

        const canvas = d3.select("#mapCanvas")
            .attr("width", width)
            .attr("height", height);

        const context = canvas.node().getContext("2d");

        const projection = d3.geoOrthographic()
            .translate([width / 2, height / 2])
            .scale(radius);

        const path = d3.geoPath().projection(projection).context(context);

        let landData, countryBorders, pinsData, largestData, fellFoundData;

        function render() {
            context.clearRect(0, 0, width, height);

            // Draw the map sphere
            context.beginPath();
            path({type: "Sphere"});
            context.fillStyle = "#0000ff"; // Blue for oceans
            context.fill();

            // Draw the land
            context.beginPath();
            path(landData);
            context.fillStyle = "#bada55"; // Green for land
            context.fill();

            // Draw country borders
            context.beginPath();
            path(countryBorders);
            context.strokeStyle = "#333";
            context.lineWidth = 1;
            context.stroke();

            // Draw heat map
            drawHeatMap();
        }

        function drawHeatMap() {
            const heatCanvas = document.createElement("canvas");
            heatCanvas.width = width;
            heatCanvas.height = height;
            const heatContext = heatCanvas.getContext("2d");

            const colorScale = d3.scaleSequential(d3.interpolateWarm).domain([0, 100]); // Adjust the domain as needed

            // Use a simple density function for demo purposes
            const density = {};
            pinsData.forEach(d => {
                const [x, y] = projection([+d.reclong, +d.reclat]);
                if (x && y) {
                    const key = `${Math.floor(x)},${Math.floor(y)}`;
                    density[key] = (density[key] || 0) + 1;
                }
            });

            Object.keys(density).forEach(key => {
                const [x, y] = key.split(',').map(Number);
                const value = density[key];
                heatContext.beginPath();
                heatContext.arc(x, y, 10, 0, 2 * Math.PI);
                heatContext.fillStyle = colorScale(value);
                heatContext.fill();
            });

            context.globalAlpha = 0.6; // Set the transparency for the heat map
            context.drawImage(heatCanvas, 0, 0);
            context.globalAlpha = 1; // Reset transparency
        }

        function loadData() {
            Promise.all([
                d3.json('https://skillet64.github.io/498/land-50m.json'),
                d3.json('https://skillet64.github.io/498/land-110m.json'),
                d3.csv('https://skillet64.github.io/498/Sheet%201-ml-Meteorite_Landings.csv'),
                d3.csv('https://skillet64.github.io/498/biggest.csv'),
                d3.csv('https://skillet64.github.io/498/ml-Meteorite_Landings%20Pivot-ml-Meteorite_Landings%20Pivot.csv', function(d, i, columns) {
                    if (i < 2) return; // Skip the first two rows
                    return {
                        year: d[columns[0]], // First column header: "fell"
                        fell: +d[columns[1]], // Second column header: "Fell"
                        Found: +d[columns[2]], // Third column header: "Found"
                        total: +d[columns[3]] // Fourth column header: "Grand Total"
                    };
                })
            ]).then(([land50, land110, mlData, biggestData, fellFoundData]) => {
                console.log('Data loaded successfully');
                console.log('fellFoundData:', fellFoundData); // Log the data to check its structure
                
                landData = topojson.feature(land50, land50.objects.land);
                countryBorders = topojson.feature(land110, land110.objects.land);
                pinsData = mlData;
                largestData = biggestData;
                
                if (fellFoundData && fellFoundData.length > 0) {
                    fellFoundData = fellFoundData;
                } else {
                    console.error('fellFoundData is undefined or empty');
                    fellFoundData = []; // Default to an empty array
                }

                render();
                drawBarChart(); // Draw the horizontal bar chart
                drawStackedBarChart(); // Draw the stacked bar chart
            }).catch(error => {
                console.error('Error loading data:', error);
            });
        }

        function drawBarChart() {
            const data = largestData.map(d => ({
                name: d.name,
                mass: +d['mass (g) (Sum)']
            }));

            const svg = d3.select('.bar-chart').append('svg')
                .attr('width', '100%')
                .attr('height', '100%'); // Adjust height based on the chart container height

            const x = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.mass)])
                .range([0, d3.select('.bar-chart').node().getBoundingClientRect().width]);

            const y = d3.scaleBand()
                .domain(data.map(d => d.name))
                .range([0, d3.select('.bar-chart').node().getBoundingClientRect().height])
                .padding(0.1);

            // Add bars
            svg.selectAll('.bar')
                .data(data)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', 0)
                .attr('y', d => y(d.name))
                .attr('width', d => x(d.mass))
                .attr('height', y.bandwidth())
                .append('title')
                .text(d => `${d.mass} grams`); // Tooltip text for the bars

            // Add y-axis
            const yAxis = d3.axisLeft(y)
                .tickSize(0); // Remove axis line

            svg.append('g')
                .attr('class', 'y-axis')
                .attr('transform', 'translate(0, 0)')
                .call(yAxis)
                .selectAll('text')
                .attr('x', -10) // Position text labels to the left of the axis
                .style('text-anchor', 'end');
        }

        function drawStackedBarChart() {
            const stack = d3.stack()
                .keys(['fell', 'Found', 'total'])
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetNone);

            const data = fellFoundData.map(d => ({
                year: d.year,
                fell: d.fell,
                Found: d.Found,
                total: d.total
            }));

            const svg = d3.select('.stacked-bar-chart').append('svg')
                .attr('width', '100%')
                .attr('height', '100%'); // Adjust height based on the chart container height

            const x = d3.scaleBand()
                .domain(data.map(d => d.year))
                .range([0, d3.select('.stacked-bar-chart').node().getBoundingClientRect().width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.fell + d.Found + d.total)])
                .nice()
                .range([d3.select('.stacked-bar-chart').node().getBoundingClientRect().height, 0]); // Adjust range to fit within the chart height

            const colors = d3.scaleOrdinal()
                .domain(['fell', 'Found', 'total'])
                .range(['#e41a1c', '#377eb8', '#4daf4a']); // Colors for different segments

            const series = stack(data);

            svg.selectAll('.layer')
                .data(series)
                .enter().append('g')
                .attr('class', 'layer')
                .attr('fill', d => colors(d.key))
                .selectAll('rect')
                .data(d => d)
                .enter().append('rect')
                .attr('x', d => x(d.data.year))
                .attr('y', d => y(d[1]))
                .attr('height', d => y(d[0]) - y(d[1]))
                .attr('width', x.bandwidth())
                .append('title')
                .text(d => `${d.key}: ${d[1] - d[0]}`);

            svg.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0, ${d3.select('.stacked-bar-chart').node().getBoundingClientRect().height})`)
                .call(d3.axisBottom(x))
                .selectAll('.tick text')
                .attr('y', 10);

            svg.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(y));
        }

        function rotateMap(longitudeDelta, latitudeDelta) {
            let [longitude, latitude] = projection.rotate();
            longitude = (longitude + longitudeDelta) % 360;
            latitude = Math.max(-90, Math.min(90, latitude + latitudeDelta)); // Constrain latitude between -90 and 90
            projection.rotate([longitude, latitude]);
            render();
        }

        loadData(); // Load and render all data

        const tooltip = d3.select(".tooltip");

        canvas.node().addEventListener("mousemove", (event) => {
            const [x, y] = d3.pointer(event, canvas.node());
            const [longitude, latitude] = projection.invert([x, y]);
            let found = false;
            pinsData.forEach(d => {
                const [px, py] = projection([+d.reclong, +d.reclat]);
                if (Math.hypot(px - x, py - y) < 5) {
                    tooltip.style("display", "block")
                        .style("left", `${event.pageX + 5}px`)
                        .style("top", `${event.pageY - 28}px`)
                        .text(d.name);
                    found = true;
                }
            });
            if (!found) tooltip.style("display", "none");
        });

        canvas.node().addEventListener("mouseleave", () => {
            tooltip.style("display", "none");
        });

        d3.select("body").call(d3.drag().on("drag", function(event) {
            const [dx, dy] = [event.dx, event.dy];
            rotateMap(dx / 10, dy / 10);
        }));
    </script>
</body>
</html>
