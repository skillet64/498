<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/versor@0.2/dist/versor.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
        }
        .error {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            font: 12px sans-serif;
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
        }
    </style>
</head>
<body>
<script type="module">
    // Set up dimensions
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Create the canvas
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    document.body.appendChild(canvas);
    const context = canvas.getContext("2d");

    // Define the projection
    const projection = d3.geoOrthographic()
        .scale(Math.min(width, height) / 2)
        .translate([width / 2, height / 2])
        .clipAngle(90);

    const path = d3.geoPath(projection, context);

    // Define the sphere
    const sphere = { type: "Sphere" };
    let landData, pinsData;

    // Create an error div
    const errorDiv = d3.select("body").append("div")
        .attr("class", "error")
        .style("display", "none");

    // Function to handle errors
    function handleError(error, fileName) {
        console.error(`Error loading ${fileName}:`, error);
        errorDiv.style("display", "block")
            .text(`Failed to load ${fileName}. Check the console for details.`);
    }

    // Function to render the map and pins
    function render() {
        context.clearRect(0, 0, width, height);
        context.beginPath();
        path(sphere);
        context.fillStyle = "#fff";
        context.fill();

        context.beginPath();
        path(landData);
        context.fillStyle = "#000";
        context.fill();

        context.beginPath();
        path(sphere);
        context.stroke();

        // Draw pins
        pinsData.forEach(d => {
            const [x, y] = projection([+d.reclong, +d.reclat]);
            context.beginPath();
            context.arc(x, y, 3, 0, 2 * Math.PI);
            context.fillStyle = "red";
            context.fill();
            context.strokeStyle = "black";
            context.stroke();
        });
    }

    // Variables for drag
    let v0, q0, r0, a0;

    // Load and render data
    async function loadData() {
        try {
            const land50Response = await fetch('https://skillet64.github.io/498/land-50m.json');
            const land50Data = await land50Response.json();
            landData = topojson.feature(land50Data, land50Data.objects.land);

            const land110Response = await fetch('https://skillet64.github.io/498/land-110m.json');
            const land110Data = await land110Response.json();
            // Optionally use land110Data here if needed for fallback or different rendering

            render();

            // Load and plot pins
            const pinsResponse = await fetch('https://skillet64.github.io/498/ml-Meteorite_Landings.csv');
            const pinsText = await pinsResponse.text();
            pinsData = d3.csvParse(pinsText);

            // Add tooltip functionality
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip");

            canvas.addEventListener("mousemove", (event) => {
                const [x, y] = d3.pointer(event);
                const [longitude, latitude] = projection.invert([x, y]);
                const closest = pinsData.reduce((closest, d) => {
                    const [px, py] = projection([+d.reclong, +d.reclat]);
                    const distance = Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2));
                    return distance < closest.distance ? { distance, data: d } : closest;
                }, { distance: Infinity });

                if (closest.distance < 10) { // Adjust the distance threshold as needed
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(closest.data.name || "No name")
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");
                } else {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                }
            });

            canvas.addEventListener("mouseout", () => {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });

            render(); // Ensure pins are drawn after data is loaded

            // Set up drag behavior
            const drag = d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged);

            d3.select(canvas).call(drag);

            function dragstarted(event) {
                const [x, y] = d3.pointer(event);
                const [longitude, latitude] = projection.invert([x, y]);
                v0 = versor.cartesian([longitude * Math.PI / 180, latitude * Math.PI / 180]);
                q0 = versor.rotation(projection.rotate());
            }

            function dragged(event) {
                const [x, y] = d3.pointer(event);
                const [longitude, latitude] = projection.invert([x, y]);
                const v1 = versor.cartesian([longitude * Math.PI / 180, latitude * Math.PI / 180]);
                const delta = versor.delta(v0, v1);
                const q1 = versor.multiply(q0, delta);
                projection.rotate(versor.rotation(q1));
                render(); // Re-render map and pins
            }
        } catch (error) {
            handleError(error, 'GeoJSON or CSV files');
        }
    }

    loadData();

    // Handle window resizing
    window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        projection.translate([canvas.width / 2, canvas.height / 2])
            .scale(Math.min(canvas.width, canvas.height) / 2);
        render();
    });
</script>
</body>
</html>
