<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/versor@0.2/dist/versor.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
        }
        .error {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 5px;
            font: 12px sans-serif;
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
        }
    </style>
</head>
<body>
<script type="module">
    // Set up dimensions
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Create the canvas
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    document.body.appendChild(canvas);
    const context = canvas.getContext("2d");

    // Define the projection
    const projection = d3.geoOrthographic()
        .scale(Math.min(width, height) / 2)
        .translate([width / 2, height / 2])
        .clipAngle(90);

    const path = d3.geoPath(projection, context);

    // Define the sphere and land data
    const sphere = { type: "Sphere" };
    let land50, land110;

    // Function to handle errors
    function handleError(error, fileName) {
        console.error(`Error loading ${fileName}:`, error);
        errorDiv.style("display", "block")
            .text(`Failed to load ${fileName}. Check the console for details.`);
    }

    // Function to render the map
    function render(land) {
        context.clearRect(0, 0, width, height);
        context.beginPath();
        path(sphere);
        context.fillStyle = "#fff";
        context.fill();

        context.beginPath();
        path(land);
        context.fillStyle = "#000";
        context.fill();

        context.beginPath();
        path(sphere);
        context.stroke();
    }

    // Load and render data
    Promise.all([
        fetch('https://example.com/path/to/land-50m.json').then(response => response.json()).then(data => topojson.feature(data, data.objects.land)).catch(error => handleError(error, 'land-50m.json')),
        fetch('https://example.com/path/to/land-110m.json').then(response => response.json()).then(data => topojson.feature(data, data.objects.land)).catch(error => handleError(error, 'land-110m.json'))
    ]).then(([land50Data, land110Data]) => {
        land50 = land50Data;
        land110 = land110Data;
        render(land50);

        // Load and plot pins
        fetch('https://skillet64.github.io/498/ml-Meteorite_Landings.csv')
            .then(response => response.text())
            .then(text => d3.csvParse(text))
            .then(data => {
                // Add pins
                data.forEach(d => {
                    const [x, y] = projection([+d.reclong, +d.reclat]);
                    context.beginPath();
                    context.arc(x, y, 3, 0, 2 * Math.PI);
                    context.fillStyle = "red";
                    context.fill();
                    context.strokeStyle = "black";
                    context.stroke();
                });

                // Add tooltip functionality
                canvas.addEventListener("mousemove", (event) => {
                    const [x, y] = d3.pointer(event);
                    const [longitude, latitude] = projection.invert([x, y]);
                    const closest = data.reduce((closest, d) => {
                        const [px, py] = projection([+d.reclong, +d.reclat]);
                        const distance = Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2));
                        return distance < closest.distance ? { distance, data: d } : closest;
                    }, { distance: Infinity });

                    if (closest.distance < 10) { // Adjust the distance threshold as needed
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(closest.data.name || "No name")
                            .style("left", (event.pageX + 5) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    } else {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    }
                });

                canvas.addEventListener("mouseout", () => {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });
            })
            .catch(error => handleError(error, 'CSV file'));

        // Set up drag behavior
        const drag = d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged);

        d3.select(canvas).call(drag);

        function dragstarted(event) {
            const [x, y] = d3.pointer(event);
            const [longitude, latitude] = projection.invert([x, y]);
            v0 = versor.cartesian([longitude * Math.PI / 180, latitude * Math.PI / 180]);
            q0 = versor.rotation(projection.rotate());
        }

        function dragged(event) {
            const [x, y] = d3.pointer(event);
            const [longitude, latitude] = projection.invert([x, y]);
            const v1 = versor.cartesian([longitude * Math.PI / 180, latitude * Math.PI / 180]);
            const delta = versor.delta(v0, v1);
            const q1 = versor.multiply(q0, delta);
            projection.rotate(versor.rotation(q1));
            render(land50);
        }
    }).catch(error => handleError(error, 'GeoJSON files'));

    // Handle window resizing
    window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        projection.translate([canvas.width / 2, canvas.height / 2])
            .scale(Math.min(canvas.width, canvas.height) / 2);
        render(land50);
    });
</script>
</body>
</html>
